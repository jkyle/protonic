{
  "name": "Protonic",
  "tagline": "A small library for managing application state with streams.",
  "body": "# PROTONIC\r\n\r\n_It's like other things, only different._\r\n\r\n## Overview\r\n\r\nProtonic is a (very) simple (framework agnostic) library for managing state through streams. It's inspired by other popular state-management patterns and libraries (notably Redux, Flux, and RxJS), but makes certain assumptions and trade-offs in support of reducing complexity and developing applications following a specific pattern. By itself, Protonic isn't much of a framework, but _is_ designed to work with a simple one-way data flow pattern that we'll describe here. (This pattern isn't anything new, but for the sake of this document and this particular flavor of the pattern we'll call it the Protonic Pattern.)\r\n\r\n## Getting Started (Quickly)\r\n\r\nTo use Protonic in your app, install it with npm:\r\n\r\n`npm install protonic --save`\r\n\r\n\r\n```javascript\r\nimport Immutable from 'immutable';\r\nimport { Stream } from 'protonic';\r\n\r\n// To create a stream:\r\nlet initialState = Immutable.Map({ name: 'Jessika Pava' })\r\nlet myStream = new Stream(initialState);\r\n\r\n\r\n// To subscribe to a stream:\r\nlet subscriber = myStream.subscribe(state => console.log(state.get('name')));\r\n// immediately logs \"Jessika Pava\"\r\n\r\n// To send state to a stream:\r\nmyStream.state = myStream.state.set('name', '\"Snap\" Wexley');\r\n// logs '\"Snap\" Wexley'\r\n\r\n// To unsubscribe from a stream:\r\nsubscriber.unsubscribe();\r\n\r\nmyStream.state = myStream.state.set('name', 'KarÃ© Kun');\r\n// nothing logs.\r\n```\r\n\r\n## One-Way Data Flow\r\n\r\n![Diagram of whole system](./diagrams/all-diagram.png)\r\n\r\n### Terminology\r\n\r\n\r\n#### State\r\n**State** is an `Immutable` data structure that represents the data needed to render your application. This includes the state of the UI in addition to data that might be retrieved from a database or server.\r\n\r\n\r\n#### Streams\r\nA **Stream** is a canonical source of **state** for a part of an application. Observers can subscribe to a stream to receive new state when the stream updates. Streams in Protonic are similar to streams in other frameworks (they are actually very similar to BehaviorSubjects in RxJS), but make certain assumptions to simplify things.\r\n\r\n1. Streams remember the last state emitted.\r\n2. Streams won't emit falsey values.\r\n3. Streams won't emit a new state if it's content is the same as the current state of the stream.\r\n4. Streams don't \"complete\".\r\n5. Streams make their internal state available without needing to subscribe to the stream.\r\n6. Streams only work with immutable data.\r\n\r\n![Diagram of Streams](./diagrams/stream-diagram.png)\r\n\r\n#### Transformers\r\nA **transformer** is a function that gets the current state of a stream, transforms the state into new state, and sends the new state back to the stream.\r\n\r\nA transformer is *only* allowed to operate on state from one stream. It may not affect state outside of itself. Additionally, *Only* transformers are allowed to change the state of stream.\r\n\r\n![Diagram of Transformers](./diagrams/transformer-diagram.png)\r\n\r\n\r\n#### Actions\r\nSince transformers are each allowed to only transform state from one stream, and are not allowed to have side-effects, **actions** are what we use to combine state changes across streams, as well as perform side-effects (such as Ajax request to fetch data from a server).\r\n\r\nActions are allowed to call transformers for different streams, but actions may not manipulate streams directly. Since transformers are not technically reducers (they don't receive state as an argument or return state), they cannot be batched together in on atomic state change. This means that a transform of state from one stream should not depend on a transform of state from another stream happening in a particular order.\r\n\r\n![Diagram of Actions](./diagrams/action-diagram.png)\r\n\r\n#### Funnels\r\nA **Funnel** is just a special kind of stream that takes *other* streams as its input. The funnel will combine the state from the other streams into a new state object. The Protonic Pattern is a big believer that there should only be one source of state for UI components to subscribe to. Typically an AppState will be created by **Funnel**-ing the individual source streams into one state object.\r\n\r\nFunnels initialize with an empty `Immutable.Map` as its value, but won't emit state to observers until *all* of the source streams have sent state to the Funnel.\r\n\r\n\r\n#### Views\r\nA **View** is another special kind of stream that takes a single stream as input along with a function that computes new state from the state of the source stream.\r\n\r\nSince streams only emit new state to observers when the new state is distinct from the current state, views will only emit when the computed state changes. This is a good way to prevent a lot of unnecessary calls to observers when the application state changes.\r\n\r\n\r\n### Wiring Up UI Components\r\nSince the Protonic Pattern is framework agnostic, the specific implementation details will be determined by whichever framework is rendering your interface. (It's also important to note that the pattern isn't limited to an interface being a *UI* interface.)\r\n\r\n\r\n#### Example components\r\nWe'll demonstrate an oversimplified example of components in both Angular (1.5, but the concept applies as well to 2.0) and React. In both cases, we'll assume that a stream called `AppStream` will send the following state:\r\n\r\n```javascript\r\nImmutable.Map({\r\n  id: 3,\r\n  name: 'Jessika Pava',\r\n  callsign: 'Blue Three',\r\n  fighter: 'T-70 X-Wing',\r\n  affiliation: 'Resistance',\r\n  sorties: 18\r\n})\r\n```\r\n\r\n\r\n#### Angular 1.5\r\n\r\n*In an effort to reduce complexity, we aren't using Angular's Dependency Injection here. If you need DI, you can create a service as a wrapper around the stream. Additionally, changes in state won't automatically trigger a digest cycle. An example of how to do with will be provided later on.*\r\n\r\n```javascript\r\n\r\nimport AppStream from 'path/to/app-stream';\r\nimport { incrementPilotSortie } from 'path/to/actions';\r\n\r\nexport default {\r\n  template: '... some template ...',\r\n  bindings: {},\r\n  controller: function(){\r\n    let subscriber;\r\n    // Initial state.\r\n    this.pilot = {\r\n      name: '',\r\n      callsign: ''\r\n      fighter: '',\r\n      affiliation: '',\r\n      sorties: 0\r\n    };\r\n\r\n    // Lifecycle methods.\r\n    // $onInit sets up the state subscriber.\r\n    this.$onInit = function () {\r\n      subscriber = AppStream.subscribe(state => this.pilot = state.toJS())\r\n    }\r\n\r\n    // $onDestroy cleans up the subscriber\r\n    this.$onDestroy = () => {\r\n      subscriber.unsubscribe()\r\n    }\r\n\r\n    // A method to be called from the UI\r\n    // which in turn calls an action.\r\n    this.incrementSortie = () => {\r\n      incrementPilotSortie(this.pilot.id);\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n#### React\r\n\r\n```javascript\r\nimport AppStream from 'path/to/app-stream';\r\nimport { incrementPilotSortie } from 'path/to/actions';\r\n\r\nexport default React.createClass({\r\n  getInitialState: function() {\r\n    return { pilot:{\r\n              name: '',\r\n              callsign: ''\r\n              fighter: '',\r\n              affiliation: '',\r\n              sorties: 0\r\n            }\r\n          }\r\n  },\r\n  componentDidMount: function() {\r\n    this.subscriber = AppStream.subscribe(state => this.setState({ pilot: state.toJS() }));\r\n  },\r\n  componentWillUnmount: function() {\r\n    this.subscriber.unsubscribe();\r\n  },\r\n  incrementSortie: function() {\r\n    incrementPilotSortie(this.state.pilot.id);\r\n  },\r\n  render: function() {\r\n    return ( /*... some jsx  ... */ );\r\n  }\r\n})\r\n```\r\n\r\n\r\n## API\r\n\r\n### Streams\r\nA stream is created by calling `new Stream()` an optionally passing in an initial state. If you do\r\npass in an initial state, it must be an `Immutable` data structure.\r\n\r\n```javascript\r\nimport { Stream } from 'protonic';\r\n\r\nlet myStream = new Stream(Immutable.Map({name: 'Testor'}));\r\n```\r\n\r\nYou can get the current state of a stream at any time by access the `.state` property.\r\n\r\n```javascript\r\nlet currentState = myStream.state;\r\n// currentState is Immutable.Map of {name: 'Testor'}\r\n```\r\n\r\nYou can subscribe to any changes to the stream's state with the `.subscribe` method. `.subscribe` takes a callback function (we'll call it an _observer_) that is called any time the stream's state changes. `.subscribe` returns an object with an `.unsubscribe` method. `.unsubscribe` should be called whenever the observer is done listening to state changes.\r\n\r\n```javascript\r\nlet subscriber = myStream.subscribe(state => console.log(state));\r\n// logs out state anytime state changes.\r\n\r\n// later on\r\nsubscriber.unsubscribe();\r\n```\r\n\r\nYou can send new state to the stream with the `.next(newState)` method. This will send the state to any observers, provided that the new state is not falsey and is distinct from the stream's current state.\r\n\r\n```javascript\r\nmyStream.next(Immutable.Map({name: 'Snap'}))\r\n// myStream.state is now Immutable.Map of {name: 'Snap'}\r\n```\r\n\r\nProtonic also allows you to set the state through the `.state` setter property. It is functionally equivalent to calling `.next(newState)`, but might be more declarative:\r\n\r\n```javascript\r\nmyStream.state = Immutable.Map({name: 'Snap'});\r\n// myStream.state is now Immutable.Map of {name: 'Snap'}\r\n```\r\n\r\n\r\n### Funnels\r\nA funnel is created with `new Funnel()` and takes a required argument which is a map of streams to combine into one state object. The key for each stream in the map will end up corresponding to the key for that stream's part of the state in the combined state object.\r\n\r\n```javascript\r\nimport { Funnel } from 'protonic';\r\nimport pilotStream from 'path/to/pilot-stream';\r\nimport shipStream from 'path/to/ship-stream';\r\n\r\nlet AppStream = new Funnel(Immutable.Map({\r\n  Pilots: pilotStream,\r\n  Ships: shipStream\r\n}))\r\n```\r\n\r\nJust like with Streams, you can get the current state of the Funnel with the `.state` property.\r\n\r\n```javascript\r\nlet currentState = AppStream.state;\r\n// currentState is Immutable.Map of\r\n// { Pilot: { name: 'Testor' },\r\n//   Ship: { type: 'X-Wing' } }\r\n```\r\n\r\nAlso like Streams, you can subscribe to state changes with the `.subscribe` method. Note that state will not be sent to observers until all of the source streams have emitted state to the funnel.\r\n\r\n```javascript\r\nlet subscriber = AppStream.subscribe(state => console.log(state));\r\n// logs out state anytime state changes.\r\n\r\n// later on\r\nsubscriber.unsubscribe();\r\n```\r\n\r\nFinally, when you are done with a Funnel, you can call `.destroy` method to clean up the Funnel and unsubscribe from the source streams.\r\n\r\n```javascript\r\nAppStream.destroy()\r\n```\r\n\r\n\r\n### Views\r\nA View is created with `new View(soureStream, viewFunction)`, and requires a source stream which it will subscribe to and a view function to change the shape of the state before emitting to its own subscribers.\r\n\r\n```javascript\r\nimport { View } from 'protonic';\r\nimport AppStream from 'path/to/app-stream';\r\n\r\nlet myView = new View(AppStream, state => {\r\n  let pilotName = state.getIn(['Pilot', 'name']);\r\n  let shipType = state.getIn(['Ship', 'type']);\r\n  return Immutable.Map({\r\n    description: pilotName + ' flies an ' + shipType\r\n  });\r\n})\r\n```\r\n\r\nAs with Streams and Funnels, the current state of a View is accessible by its `.state` property:\r\n\r\n```javascript\r\nlet currentState = myView.state;\r\n// currentState is Immutable.Map of { description: 'Testor flies an X-Wing' }\r\n```\r\n\r\nAlso like Streams and Funnels, you can subscribe to state changes from the view. Just like Streams, observers will only receive state if the new state calculated by the View is distinct from the last state calculated by the View.\r\n\r\n```javascript\r\nlet subscriber = myView.subscribe(state => console.log(state));\r\n// logs out state anytime state changes.\r\n\r\n// later on\r\nsubscriber.unsubscribe();\r\n```\r\n\r\nAnd, like Funnels, when you are done with a View, it can be cleaned up with the `.destroy` method.\r\n\r\n```javascript\r\nmyView.destroy();\r\n```\r\n\r\n\r\n## Actions and Transformers\r\n**TODO** Show code examples for actions and transformers\r\n\r\n\r\n## Logging and Debugging\r\n**TODO** Talk about Logging/Debugging with Stacks.\r\n\r\n\r\n## Why Protonic\r\n**TODO** Talk more about philosophy of Protonic\r\n\r\n**TODO** Talk about gotchas (i.e. Actions cannot subscribe to streams)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}